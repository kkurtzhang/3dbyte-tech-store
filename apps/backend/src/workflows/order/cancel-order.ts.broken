import {
  createWorkflow,
  WorkflowResponse,
  createStep,
  StepResponse,
  container,
} from "@medusajs/framework/workflows-sdk";
import { Modules } from "@medusajs/framework/utils";
import { MedusaError } from "@medusajs/framework/utils";

/**
 * Step to check if order can be cancelled
 */
const checkOrderCancellableStep = createStep(
  "check-order-cancellable",
  async ({ orderId, query }: { orderId: string; query: any }) => {
    const { data: orders } = await query.graph({
      entity: "order",
      fields: ["id", "status", "fulfillment_status", "payment_status"],
      filters: {
        id: orderId,
      },
    });

    if (!orders || orders.length === 0) {
      throw new MedusaError(
        MedusaError.Types.NOT_FOUND,
        `Order with id ${orderId} not found`
      );
    }

    const order = orders[0];

    // Check if order is already cancelled
    if (order.status === "canceled") {
      throw new MedusaError(
        MedusaError.Types.INVALID_DATA,
        "Order is already cancelled"
      );
    }

    // Check if order can be cancelled based on status
    // Orders that cannot be cancelled: already shipped, delivered, or partially shipped
    const nonCancellableStatuses = [
      "shipped",
      "delivered",
      "partially_shipped",
    ];

    if (nonCancellableStatuses.includes(order.fulfillment_status)) {
      throw new MedusaError(
        MedusaError.Types.INVALID_DATA,
        `Order cannot be cancelled. Current fulfillment status: ${order.fulfillment_status}`
      );
    }

    return new StepResponse({ order });
  }
);

/**
 * Step to cancel order fulfillments
 */
const cancelOrderFulfillmentsStep = createStep(
  "cancel-order-fulfillments",
  async ({ order, query }: { order: any; query: any }) => {
    // If order has fulfillments, cancel them
    if (order.fulfillment_status === "fulfilled" ||
        order.fulfillment_status === "partially_fulfilled") {

      const { data: fulfillments } = await query.graph({
        entity: "order_fulfillment",
        fields: ["id", "status"],
        filters: {
          order_id: order.id,
        },
      });

      // Cancel each fulfillment
      for (const fulfillment of fulfillments) {
        if (fulfillment.status !== "canceled" &&
            fulfillment.status !== "shipped") {
          await query.graph({
            entity: "order_fulfillment",
            action: "update",
            data: {
              id: fulfillment.id,
              status: "canceled",
              canceled_at: new Date().toISOString(),
            },
          });
        }
      }
    }

    return new StepResponse({ order });
  }
);

/**
 * Step to refund payment if applicable
 */
const refundPaymentStep = createStep(
  "refund-order-payment",
  async ({ order, query }: { order: any; query: any }) => {
    let refundId: string | undefined;

    // Only refund if payment was captured and not already refunded
    if (order.payment_status === "captured") {
      const { data: payments } = await query.graph({
        entity: "payment",
        fields: ["id", "amount", "currency_code", "captured_amount"],
        filters: {
          order_id: order.id,
        },
      });

      for (const payment of payments) {
        if (payment.captured_amount > 0) {
          try {
            // Create a refund for the captured amount
            const { data: refunds } = await query.graph({
              entity: "refund",
              action: "create",
              data: {
                amount: payment.captured_amount,
                currency_code: payment.currency_code,
                payment_id: payment.id,
                order_id: order.id,
                reason: "requested_by_customer",
                note: "Order cancelled by customer",
                created_by: "customer",
              },
            });

            refundId = refunds[0]?.id;
          } catch (error) {
            console.error(`Failed to refund payment ${payment.id}:`, error);
            // Don't throw - allow cancellation to proceed even if refund fails
            // Admin can handle refunds manually
          }
        }
      }
    }

    return new StepResponse({ refundId, order });
  }
);

/**
 * Step to update order status to cancelled
 */
const updateOrderStatusStep = createStep(
  "update-order-status",
  async ({ order, query }: { order: any; query: any }) => {
    const { data: updatedOrders } = await query.graph({
      entity: "order",
      action: "update",
      data: {
        id: order.id,
        status: "canceled",
        canceled_at: new Date().toISOString(),
      },
      fields: ["id", "status", "canceled_at"],
    });

    return new StepResponse(updatedOrders[0]);
  }
);

/**
 * Main workflow for cancelling an order
 */
export const cancelOrderWorkflow = createWorkflow(
  "cancel-order",
  function (input: { orderId: string }) {
    const query = container.resolve("query");

    // Check if order can be cancelled
    const { order } = checkOrderCancellableStep({ orderId: input.orderId, query });

    // Cancel any fulfillments
    const { order: orderWithFulfillments } = cancelOrderFulfillmentsStep({ order, query });

    // Refund payment if applicable
    const { refundId, order: orderWithRefund } = refundPaymentStep({
      order: orderWithFulfillments,
      query,
    });

    // Update order status to cancelled
    const cancelledOrder = updateOrderStatusStep({ order: orderWithRefund, query });

    return new WorkflowResponse({
      order: cancelledOrder,
      refundId,
    });
  }
);
